# 1. fopen与open的区别

```cpp
int open(const char *path, int access,int mode)  
    path 要打开的文件路径和名称                             
    access 访问模式，宏定义和含义如下：                          
        O_RDONLY         1    只读打开                           
        O_WRONLY         2    只写打开                           
        O_RDWR           4    读写打开                       
        还可选择以下模式与以上3种基本模式相与：                      
            O_CREAT     0x0100   创建一个文件并打开                  
            O_TRUNC     0x0200   打开一个已存在的文件并将文件长度设置为0，其他属性保持           
            O_EXCL      0x0400   未使用                              
            O_APPEND    0x0800   追加打开文件                       
            O_TEXT      0x4000   打开文本文件翻译CR-LF控制字符       
            O_BINARY    0x8000   打开二进制字符，不作CR-LF翻译                                                          
    mode 该参数仅在access=O_CREAT方式下使用，其取值如下：        
        S_IFMT      0xF000   文件类型掩码                        
        S_IFDIR     0x4000   目录                                
        S_IFIFO     0x1000   FIFO 专用                           
        S_IFCHR     0x2000   字符专用                            
        S_IFBLK     0x3000   块专用                              
        S_IFREG     0x8000   只为0x0000                          
        S_IREAD     0x0100   可读                                
        S_IWRITE    0x0080   可写                                
        S_IEXEC     0x0040   可执行  
```

```cpp
FILE *fopen(char *filename, char *mode)  
    filename 文件名称  
    mode 打开模式：                                              
        r   只读方式打开一个文本文件                             
        rb  只读方式打开一个二进制文件                           
        w   只写方式打开一个文本文件                             
        wb  只写方式打开一个二进制文件                           
        a   追加方式打开一个文本文件                             
        ab  追加方式打开一个二进制文件                           
        r+  可读可写方式打开一个文本文件                         
        rb+ 可读可写方式打开一个二进制文件                       
        w+  可读可写方式创建一个文本文件                         
        wb+ 可读可写方式生成一个二进制文件                       
        a+  可读可写追加方式打开一个文本文件                     
        ab+ 可读可写方式追加一个二进制文件  
```

区别：

1. 缓冲文件系统与非缓冲文件系统的区别

   缓冲文件系统（fopen）：在内存为每个文件开辟一个缓存区，当执行读操作，从磁盘文件将数据读入内存缓冲区，装满后从内存缓冲区依次读取数据。写操作同理。内存缓冲区的大小影响着实际操作外存的次数，缓冲区越大，操作外存的次数越少，执行速度快，效率高。缓冲区大小由机器而定。

   借助文件结构体指针对文件管理，可读写字符串、格式化数据、二进制数据。

   非缓冲文件系统(open)：依赖操作系统功能对文件读写，不设文件结构体指针，只能读写二进制文件。

2. open属于低级IO，fopen属于高级IO

3. open返回文件描述符，属于用户态，读写需进行用户态与内核态切换。 fopen返回文件指针。

4. open是系统函数，不可移植；fopen是标准C函数，可移植

5. 一般用fopen打开普通文件，open打开设备文件

6. 如果顺序访问文件，fopen比open快；如果随机访问文件，open比fopen快。



# 2. linux用户态与内核态

权限不同，用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“**为所欲为**”。

从用户态到内核态切换可以通过三种方式：

1. 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。



# 3.Printf的缓冲机制

printf函数实际上只是输出到了标准输出缓冲队列stdout上，并没有实实在在的打印到屏幕上，标准输出是行缓冲机制，也就是说，遇到\n，就会刷新缓冲区，输出到屏幕上。



# 4.wait/waitpid

僵尸进程: 子进程退出，父进程没有回收子进程资源（PCB），则子进程变成僵尸进程
孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程,子进程的父进程成为1号
进程init进程，称为init进程领养孤儿进程

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
pid:
< -1 回收指定进程组内的任意子进程
-1 回收任意子进程
0 回收和当前调用waitpid一个组的所有子进程
> 0 回收指定ID的子进程
options:
目前在Linux中只支持WNOHANG和WUNTRACED两个选项,如果我们不想使用它们，也可以把options设为0
如果使用了WNOHANG(wait no hung)参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。
```

​    一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。

  如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时的进程状态称为僵尸（Zombie）进程。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程程都立刻被父进程清理了，为了观察到僵尸进程，我们自己写一个不正常的程序，父进程fork出子进程，子进程终止，而父进程既不终止也不调用wait清理子进程：

```c
#include <unistd.h>
#include <stdlib.h>
int main(void)
{
pid_t pid=fork();
if(pid<0) {
perror("fork");
exit(1);
}
if(pid>0) { /* parent */
    while(1);
}
/* child */
return 0;
}
```

若调用成功则返回清理掉的子进程 id，若调用出错则返回-1。

父进程调用 wait或waitpid时可能会：

+ 阻塞（如果它的所有子进程都还在运行）
+ 带子进程的终止信息立即返回（如果一个子进程已终止，正等待父进程读取其终止信
  息）。
+ 出错立即返回（如果它没有任何子进程）

这两个函数的区别是：

    + 如果父进程的所有子进程都还在运行，调用wait将使父进程阻塞，而调用waitpid时如果在options参数中指定WNOHANG可以使父进程不阻塞而立即返回0。
    + wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程。

可见，调用wait和waitpid不仅可以获得子进程的终止信息，还可以使父进程阻塞等待子进程终止，起到进程间同步的作用。如果参数status不是空指针，则子进程的终止信息通过这个参数传出，如果只是为了同步而不关心子进程的终止信息，可以将status参数指定为NULL。

```c

```

